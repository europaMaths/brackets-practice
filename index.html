<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bracket Expansion Practice</title>
  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 40px auto;
      max-width: 700px;
      padding: 20px;
      background-color: #f9fafb;
      color: #333;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      color: #2c3e50;
    }
    label {
      font-weight: bold;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }
    button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 18px;
      margin: 10px 5px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #45a049;
    }
    .feedback {
      font-weight: bold;
      margin-top: 20px;
      font-size: 1.2em;
      text-align: center;
    }
    .question {
      font-size: 1.3em;
      text-align: center;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>Expand the Bracket(s)</h1>

  <label><input type="radio" name="mode" value="single" checked> Expand one bracket</label>
  <label><input type="radio" name="mode" value="double"> Expand two brackets and simplify</label>

  <div class="question" id="question"></div>
  <input type="text" id="userAnswer" placeholder="Type your expanded expression here">
  <div style="text-align:center">
    <button onclick="generateQuestion()">Generate Question</button>
    <button onclick="checkAnswer()">Check Answer</button>
    <button id="giveUpBtn" onclick="showSolution()" style="display: none;">Give Up</button>
  </div>
  <div class="feedback" id="feedback"></div>

  <script>
    window.addEventListener("load", () => {
      if (typeof MathJax !== "undefined") {
        generateQuestion();
      } else {
        console.error("MathJax failed to load.");
      }
    });

    let currentExpression = "";
    let correctAnswer = "";
    let steps = "";

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

function formatTermsForDisplay(terms) {
  return terms.map((term, index) => {
    if (index === 0) return term;
    return term.startsWith('-') ? ` - ${term.slice(1)}` : ` + ${term}`;
  }).join('');
}

function negateExpression(expr) {
  const terms = expr.match(/[+-]?[^+-]+/g) || [];
  return terms.map(term => {
    if (term.startsWith('+')) return '-' + term.slice(1);
    if (term.startsWith('-')) return '+' + term.slice(1);
    return '-' + term;
  }).join('');
}


    function getTerm(variable, usedPowers) {
      const types = ["const", "linear", "quadratic"];
      
      // Filter out already used powers
      const availableTypes = types.filter(type => !usedPowers.includes(type));
      
      // If all powers are used, default to constant
      const type = availableTypes.length > 0 ? 
                  availableTypes[Math.floor(Math.random() * availableTypes.length)] : 
                  "const";
      
      // Add the chosen power to the used powers list
      usedPowers.push(type);
      
      let coeff = getRandomInt(-5, 5);
      if (coeff === 0) coeff = 1;
      
      // Change +- to just - for clarity in the brackets
      let coeffStr = coeff < 0 ? `${coeff}` : `${coeff}`;
      
      if (type === "const") return coeffStr;
      if (type === "linear") return coeff === 1 ? `${variable}` : (coeff === -1 ? `-${variable}` : `${coeffStr}${variable}`);
      return coeff === 1 ? `${variable}^2` : (coeff === -1 ? `-${variable}^2` : `${coeffStr}${variable}^2`);
    }

    function getOuterCoefficient(variable) {
      // Ensure outer coefficient is never 1
      const types = ["number", "linear", "quadratic"];
      const type = types[Math.floor(Math.random() * types.length)];
      
      let coeff = getRandomInt(2, 5); // Using 2-5 to avoid 1
      
      if (type === "number") return coeff;
      if (type === "linear") return `${variable}`;
      return `${variable}^2`;
    }

    function expandSingle(a, terms, variable) {
      let expression = `${a}(${formatTermsForDisplay(terms)})`;
      let expanded = [];
      
      // Handle different types of outer coefficients
      if (isNaN(a)) {
        // a is a variable expression (like x or x^2)
        for (let term of terms) {
          expanded.push(multiplyTerms(a, term));
        }
      } else {
        // a is a number
        for (let term of terms) {
          expanded.push(expandTerm(a, term));
        }
      }
      
      return { 
        expression, 
        expanded: simplifyExpression(expanded.join(' + ')), 
        steps: generateSteps(a, terms, variable) 
      };
    }

    function multiplyTerms(a, b) {
      // Handle multiplication of algebraic terms
      if (b.match(/^\d+$/)) {
        const coeff = parseInt(b);
        if (coeff === 1) return `${a}`;
        if (coeff === -1) return `-${a}`;
        return `${coeff}${a}`;
      }
      
      // Extract coefficient and variable parts from term b
      const match = b.match(/^(-?)(\d*)([a-z]?(?:\^\d)?)$/);
      const sign = match[1] || "";
      let coeffStr = match[2] || "";
      let coeffB = sign + (coeffStr || "1");
      coeffB = parseInt(coeffB);
      
      let varB = match[3] || "";
      
      // Extract variable and power from a
      const matchA = a.match(/^([a-z])(?:\^(\d))?$/);
      if (!matchA) return `${a} × ${b}`; // Fallback for complex expressions
      
      let varA = matchA[1];
      let powerA = matchA[2] ? parseInt(matchA[2]) : 1;
      
      // Extract variable and power from b
      let varPartB = varB.match(/^([a-z])(?:\^(\d))?$/);
      let varNameB = varPartB ? varPartB[1] : "";
      let powerB = varPartB && varPartB[2] ? parseInt(varPartB[2]) : (varNameB ? 1 : 0);
      
      // Combine powers if same variable
      if (varNameB === varA) {
        let totalPower = powerA + powerB;
        let varPart = totalPower === 1 ? varA : `${varA}^${totalPower}`;
        
        // Format the coefficient
        let coeffText = coeffB === 1 ? "" : (coeffB === -1 ? "-" : `${coeffB}`);
        return `${coeffText}${varPart}`;
      } else if (varNameB) {
        // Different variables
        let varPartA = powerA === 1 ? varA : `${varA}^${powerA}`;
        let varPartB = powerB === 1 ? varNameB : `${varNameB}^${powerB}`;
        
        // Format the coefficient
        let coeffText = coeffB === 1 ? "" : (coeffB === -1 ? "-" : `${coeffB}`);
        return `${coeffText}${varPartA}${varPartB}`;
      } else {
        // b is just a coefficient
        let varPart = powerA === 1 ? varA : `${varA}^${powerA}`;
        return `${coeffB}${varPart}`;
      }
    }

    function expandTerm(a, term) {
      const match = term.match(/^(-?\d*)([a-z]?(?:\^\d)?)$/);
      let coeff = match[1] ? parseInt(match[1]) : (match[2] ? 1 : 0);
      let rest = match[2] || "";
      let result = a * coeff;
      if (result === 1 && rest) return rest;
      if (result === -1 && rest) return `-${rest}`;
      return `${result}${rest}`;
    }

    function simplifyExpression(expr) {
      return expr.replace(/\s+/g, '')
                 .replace(/\+\-/g, '-')
                 .replace(/\-\-/g, '+')
                 .replace(/\+\+/g, '+')
                 .replace(/\-\+/g, '-')
                 .replace(/\+$/, '')
                 .replace(/^\+/, '');
    }
    
    // Function to combine like terms and fully simplify an expression
    function combineAndSimplify(expr) {
      let simplified = simplifyExpression(expr);
      
      // Split the expression into terms
      const terms = simplified.match(/[+-]?[^+-]+/g) || [];
      if (!terms.length) return simplified;
      
      // Group terms by their variable part
      const groups = {};
      
      terms.forEach(term => {
        // Extract the sign, coefficient, and variable parts
        const match = term.match(/([+-]?)(\d*)([a-z]\^?\d*|$)/);
        if (!match) return;
        
        const sign = match[1] || "+";
        const coefficient = match[2] || "1";
        const variable = match[3] || "";
        
        // Calculate the actual coefficient with sign
        let value = parseInt((sign === "-" ? "-" : "") + coefficient);
        
        // Add to the appropriate group
        if (!groups[variable]) groups[variable] = 0;
        groups[variable] += value;
      });
      
      // Reconstruct the expression from combined terms
      let result = "";
      Object.keys(groups).sort().forEach(variable => {
        const coefficient = groups[variable];
        if (coefficient === 0) return;
        
        // Format the term based on coefficient value
        if (coefficient > 0) {
          if (result) result += "+";
          if (coefficient === 1 && variable) {
            result += variable;
          } else {
            result += coefficient + variable;
          }
        } else if (coefficient < 0) {
          if (coefficient === -1 && variable) {
            result += "-" + variable;
          } else {
            result += coefficient + variable;
          }
        }
      });
      
      return result || "0";
    }

    function generateSteps(a, terms, variable) {
  let original = `${a}(${formatTermsForDisplay(terms)})`;
  let distributed = [];

  if (isNaN(a)) {
    // a is a variable expression like x or x^2
    for (let term of terms) {
      distributed.push(multiplyTerms(a, term));
    }
  } else {
    // a is a number
    for (let term of terms) {
      distributed.push(expandTerm(a, term));
    }
  }

  const expanded = simplifyExpression(distributed.join(' + '));
  return `Step: Distribute \\(${a}\\) to each term:<br>\\(${original} = ${expanded}\\)`;
}


    function generateQuestion() {
      document.getElementById("giveUpBtn").style.display = "none";
      document.getElementById("feedback").innerHTML = "";
      document.getElementById("userAnswer").value = "";

      const mode = document.querySelector('input[name="mode"]:checked').value;
      const variables = "abcdefghijklmnopqrstuvwxyz".split("");
      const useTwoVars = Math.random() < 0.25;
      const [v1, v2] = shuffle(variables).slice(0, useTwoVars ? 2 : 1);

      if (mode === "single") {
        // Generate outer coefficient (never 1)
        const a = getOuterCoefficient(v1);
        
        // 80% chance of 2 terms, 20% chance of 3 terms
        const numTerms = Math.random() < 0.8 ? 2 : 3;
        
        // Track used powers to avoid repetition
        const usedPowers = [];
        const terms = Array.from({ length: numTerms }, () => getTerm(v1, usedPowers));
        
        const { expression, expanded, steps: stepText } = expandSingle(a, terms, v1);
        currentExpression = expression;
        correctAnswer = expanded;
        steps = stepText;
        document.getElementById("question").innerHTML = `Expand: \\( ${expression} \\)`;
      } else {
        // For double bracket expansion
        const a1 = getOuterCoefficient(v1);
        const a2 = getOuterCoefficient(useTwoVars ? v2 : v1);
        
        // 80% chance of 2 terms, 20% chance of 3 terms for each bracket
        const numTerms1 = Math.random() < 0.8 ? 2 : 3;
        const numTerms2 = Math.random() < 0.8 ? 2 : 3;
        
        const usedPowers1 = [];
        const usedPowers2 = [];
        
        const t1 = Array.from({ length: numTerms1 }, () => getTerm(v1, usedPowers1));
        const t2 = Array.from({ length: numTerms2 }, () => getTerm(useTwoVars ? v2 : v1, usedPowers2));
        
        const first = expandSingle(a1, t1, v1);
        const second = expandSingle(a2, t2, useTwoVars ? v2 : v1);

        const useSubtraction = Math.random() < 0.5;

        if (useSubtraction) {
          currentExpression = `${a1}(${formatTermsForDisplay(t1)}) - ${a2}(${formatTermsForDisplay(t2)})`;
          const negatedSecond = negateExpression(second.expanded);
          correctAnswer = combineAndSimplify(`${first.expanded} + ${negatedSecond}`);
          steps = `Step 1: Expand first bracket:<br>${first.steps}<br><br>` +
        `Step 2: Expand second bracket:<br>${second.steps}<br><br>` +
        `Step 3: ${useSubtraction ? 'Subtract' : 'Add'} the expansions:<br>` +
        `\\(${first.expanded} ${useSubtraction ? '-' : '+'} (${second.expanded}) = ${correctAnswer}\\)`;
        } else {
          currentExpression = `${a1}(${formatTermsForDisplay(t1)}) + ${a2}(${formatTermsForDisplay(t2)})`;
          correctAnswer = combineAndSimplify(`${first.expanded} + ${second.expanded}`);
          steps = `Step 1: Expand first bracket:<br>${first.steps}<br><br>` +
        `Step 2: Expand second bracket:<br>${second.steps}<br><br>` +
        `Step 3: ${useSubtraction ? 'Subtract' : 'Add'} the expansions:<br>` +
        `\\(${first.expanded} ${useSubtraction ? '-' : '+'} (${second.expanded}) = ${correctAnswer}\\)`;
        }


        document.getElementById("question").innerHTML = `Expand and simplify: \\( ${currentExpression} \\)`;
      }
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, "question"]);
    }

    function checkAnswer() {
      let user = simplifyExpression(document.getElementById("userAnswer").value.toLowerCase());
      let correct = correctAnswer.toLowerCase();
      
      // Normalize to handle 1x versus x
      user = user.replace(/\b1([a-z])/g, '$1');
      correct = correct.replace(/\b1([a-z])/g, '$1');
      
      // For double bracket problems, ensure both answers are fully simplified
      if (document.querySelector('input[name="mode"]:checked').value === "double") {
        user = combineAndSimplify(user);
        correct = combineAndSimplify(correct);
      }
      
      const sortedUser = sortTerms(user);
      const sortedCorrect = sortTerms(correct);

      if (sortedUser === sortedCorrect) {
        document.getElementById("feedback").innerText = "✅ Correct!";
      } else {
        document.getElementById("feedback").innerText = "❌ Not quite. Try again.";
        document.getElementById("giveUpBtn").style.display = "inline-block";
      }
    }

    function showSolution() {
      document.getElementById("feedback").innerHTML = `${steps}<br><br>Final Answer: \\( ${correctAnswer} \\)`;
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, "feedback"]);
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function sortTerms(expr) {
      return expr.split(/(?=\+|\-)/).map(t => t.trim()).sort().join(" ");
    }
  </script>
</body>
</html>